import os
import numpy as np
from astropy.coordinates import SkyCoord
from astropy import units as u
from photutils import SkyCircularAperture, SkyCircularAnnulus, aperture_photometry
from astropy.io import fits
import datetime
import random
import matplotlib.pyplot as plt
from astropy.time import Time


def photometry(target, dirtarget, filters, date, coords, comparison_coords,
               comparison_mag, verbose=False):

    add_WCS_info(target, dirtarget, filters, verbose)

    aper_sum, aper_sum_c, date_obs = perform_photometry(filters, dirtarget,
                                                        coords, comparison_coords)

    target_mag = counts_to_mag(comparison_mag, aper_sum, aper_sum_c)

    mag_plot(target_mag, date_obs, target, date)


def add_WCS_info(target, dirtarget, filters, verbose=False):
    """Adds accurate WCS information to all headers in dataset.

    Finds coordinates of stars using imstar command and WCS information
    generated by astrometry.net and writes information to a table called
    new-image.tab. It then adds the WCS information from new-image.fits to the
    headers of all the images in the dataset to get a preliminary estimate of
    the true WCS information. It writes these files and then uses imstar to
    correct the WCS information in each header. These files are copeied to a
    new directory withtin WCS called accurate_WCS.

    Parameters
    ----------
    target : str
        Name of target.
    dirtarget : str
        Directory containing all bias, flat, and raw science images.
    filters : list
        List containing string of each filter keyword found in header of flat 
        field and light frame images.
    verbose : boolean, optional
        Prints information about status of program.

    Returns
    -------
    None
    """
    # Creates new-images.tab file with positions of stars.
    os.chdir(os.path.join(dirtarget))
    if verbose:
        subprocess.call(['imstar', '-vhi', '700', '-tw', 'new-image.fits'])
    else:
        subprocess.call(['imstar', '-hi', '700', '-tw', 'new-image.fits'])

    # Gets header with WCS information to append to all images.
    wcsim_hdu = fits.open(os.path.join(dirtarget, 'new-image.fits'))
    wcsim_header = wcsim_hdu[0].header

    # Repeats process for each filter.
    for fil in filters:
        # Reads in all ISR images.
        os.mkdir(os.path.join(dirtarget, fil, 'WCS'))
        isr_images = glob.glob(os.path.join(dirtarget, fil, '*.fits'))

        if verbose:
            # Creates progress bar to show status to user.
            progress = progressbar.ProgressBar(widgets=[progressbar.Bar('=', '[', ']'),
                                                        ' ', progressbar.Percentage(),
                                                        ' ', progressbar.ETA()])
        for n, image in enumerate(isr_images):
            # Updates progress bar with each iteration.
            if verbose:
                time.sleep(0.01)
                progress.update(n + 1)
            other_hdu = fits.open(image)
            imagedata = other_hdu[0].data
            other_header = other_hdu[0].header
            # Finds all uncommon header keywords.
            diff = fits.HeaderDiff(wcsim_header, other_header).diff_keywords
            diff = diff[0]
        
            for i in diff:
                # Skips unneeded header keywords.
                if i in ('COMMENT', 'HISTORY'):
                    pass
                # Adds uncommon keywords and their value to images.
                else:
                    other_header.set(i, wcsim_header[i])

            # Writes file.
            hdu = fits.PrimaryHDU(imagedata, header=other_header)
            hdulist = fits.HDUList([hdu])
            out_path = os.path.join(dirtarget, fil, 'WCS', target + '_' +
                                    fil + '_{}.fits'.format(n))
            hdulist.writeto(out_path, overwrite=True)       
        if verbose:
            progress.finish() 
        
        # Moves new-image.tab to WCS folder so that it may be used by imwcs.
        move('new-image.tab', os.path.join(fil, 'WCS'))
        # Corrects WCS information in image header using the imwcs command and
        # known star coordinates in new-image.tab.
        os.chdir(os.path.join(dirtarget, fil, 'WCS'))
        isr_wcs_images = glob.glob(os.path.join(dirtarget, fil, 'WCS', '*.fits'))
        for i, image in enumerate(isr_wcs_images):
            if verbose:
                subprocess.call(['imwcs', '-wv', '-i', '100', '-c', 'new-image.tab',
                             target + '_' + fil + '_{}.fits'.format(i)])
            else:
                subprocess.call(['imwcs', '-w', '-i', '100', '-c', 'new-image.tab',
                             target + '_' + fil + '_{}.fits'.format(i)])
        # Moves corrected images to separate directory.
        isr_wcs_images = glob.glob(os.path.join(dirtarget, fil, 'WCS', '*w.fits'))
        os.mkdir(os.path.join(dirtarget, fil, 'WCS', 'accurate_WCS'))
        out_path = os.path.join(dirtarget, fil, 'WCS', 'accurate_WCS')
        for image in isr_wcs_images:
            move(image, out_path)


def perform_photometry(filters, dirtarget, coords, comparison_coords):
    """Perform aperture photometry on dataset.
    
    Creates aperture and annulus to measure the counts from the star and
    background level, respectively, for both the target star and for the
    comparison star(s) The residual aperture sum for the target and for the
    comparison stars are returned. 
    
    Inputs
    ------
    filters : list
        List containing string of each filter keyword found in header of flat 
        field and light frame images.
    dirtarget : str
        Directory containing all bias, flat, and raw science images.
    coords : tuple
        Tuple containing strings of RA and Dec of target star ((HH:MM:SS), 
        (+/-DD:MM:SS))."
    comparison_coords : tuple 
        Tuple containing strings of RA and Dec of comparison stars
        ((HH:MM:SS), (+/-DD:MM:SS))."
        
    Returns
    -------
    residual_aperture_sum : list
        List of pixel values of target star in each image with background value
        removed.
    residual_aperture_sum_c : list
        List of pixel values of comparison stars in each images with background
        value removed.
    """
    aper_sum = []
    date_obs = []
    for fil in filters:
        for path in os.listdir(os.path.join(dirtarget, fil, 'WCS', 'accurate_WCS')):
            if path.endswith('.fits'):
                o_file = os.path.join(dirtarget, fil, 'WCS', 'accurate_WCS', path)
                hdulist = fits.open(o_file)
                ra = coords[0]
                dec = coords[1]
                # Create SkyCoord object for target.
                coordinates = SkyCoord(ra, dec, unit = (u.hourangle, u.deg))
                # Define radius of aperture and inner/outer radius of annulus.
                radius = 6 * u.arcsec
                r_inner = 8 * u.arcsec
                r_outer = 12 * u.arcsec
                # Create SkyCircularAperture object for target.
                aperture = SkyCircularAperture(coordinates, radius)
                # Create SkyCircularAnnulus  object for target.
                annulus = SkyCircularAnnulus(coordinates, r_in=r_inner, r_out=r_outer)
                # Retrieve arcseconds per pixel in right ascensions value.
                secpix1 = abs(hdulist[0].header['SECPIX1'])
                # Calculate area of aperture.
                aperture_area = np.pi * ((secpix1/6)**(-1))**2
                # Calculate area of annulus.
                annulus_area = np.pi * ((secpix1/12)**(-1))**2 - np.pi * ((secpix1/8)**(-1))**2
                apers = (aperture, annulus)
                # Create photometry table including aperture sum for target
                # aperture and annulus sum for target annulus.
                phot_table = aperture_photometry(hdulist, apers)
                # Calculate background value.
                bkg_mean = phot_table['aperture_sum_1'] / annulus_area
                bkg_sum = bkg_mean * aperture_area
                # Remove background value from aperture sum and add residual
                # aperture sum to photometry table.
                final_sum = phot_table['aperture_sum_0'] - bkg_sum
                phot_table['residual_aperture_sum'] = final_sum
                # Add residual aperture sum to list to be returned by function.
                aper_sum.append(phot_table['residual_aperture_sum'][0])
                date_obs.append(hdulist[0].header['DATE-OBS'])
                
                
        aper_sum_c = []
        for path in os.listdir(os.path.join(dirtarget, fil, 'WCS', 'accurate_WCS')):
            if path.endswith('.fits'):
                o_file = os.path.join(dirtarget, fil, 'WCS', 'accurate_WCS', path)
                hdulist_c = fits.open(o_file)
                ra_c = comparison_coords[0]
                dec_c = comparison_coords[1]
                radius_c = 7 * u.arcsec
                r_inner_c = 8 * u.arcsec
                r_outer_c = 12 * u.arcsec
                # Retrieve arcseconds per pixel in right ascension value.
                secpix1 = abs(hdulist[0].header['SECPIX1'])
                # Calculate area of aperture.
                aperture_area = np.pi * ((secpix1/6)**(-1))**2
                # Calculate area of annulus.
                annulus_area = np.pi * ((secpix1/12)**(-1))**2 - np.pi * ((secpix1/8)**(-1))**2
                # Create SkyCoord object for comparison star.
                coordinates_c = SkyCoord(ra_c, dec_c, unit = (u.hourangle, u.deg))
                # Create SkyCircularAperture object for comparison star.
                aperture_c = SkyCircularAperture(coordinates_c, radius_c)
                # Create SkyCircularAnnulus object for comparison star.
                annulus_c = SkyCircularAnnulus(coordinates_c, r_in=r_inner_c, r_out=r_outer_c)
                apers = (aperture_c, annulus_c)
                # Create photometry table including aperture sum for target
                # aperture and annulus sum for target annulus.
                phot_table_c = aperture_photometry(hdulist_c, apers)
                # Calculate background value.
                bkg_mean = phot_table_c['aperture_sum_1'] / annulus_area
                bkg_sum = bkg_mean * aperture_area
                # Remove background value from aperture sum and add residual
                # aperture sum to photometry table.
                final_sum = phot_table_c['aperture_sum_0'] - bkg_sum
                phot_table_c['residual_aperture_sum_c'] = final_sum
                # Add residual aperture sum to list to be returned by function.
                aper_sum_c.append(phot_table_c['residual_aperture_sum_c'][0])
                
    return aper_sum, aper_sum_c, date_obs


def counts_to_mag(comparison_mag, aper_sum, aper_sum_c):
    target_mag = []
    for i in range(0, len(aper_sum)):
        mag = comparison_mag - 2.5 * np.log10(aper_sum[i] / aper_sum_c[i])
        target_mag.append(mag)
    return target_mag


def mag_plot(target_mag, date_obs, target, date):
    t = Time(date_obs)
    times = t.jd
    print(times)
    print(target_mag)

    x = times
    y = target_mag
    plt.title('Light Curve of {}, {}'.format(target, date))
    plt.ylabel('Magnitude')
    plt.xlabel('JD')
    plt.scatter(x,y)
    plt.gcf().autofmt_xdate()
    plt.gca().invert_yaxis()
    plt.show()
        

